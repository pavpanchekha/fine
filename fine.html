<!doctype html>
<meta charset="utf8"/>
<title>Fine Playground</title>
<style>
  body { max-width: 35em; margin: 2em auto; padding: 0 1em;}

  #prelude { display: none }
  .results { color: #888 }
  .results:before { content: " ⇒ " }
  .defined:after { content: " ✓"; color: green }
  .error { color: red; padding-left: 1em;}
  #src {width: calc(100% - 1em); margin: 0; border: 0;
  border-top: 1px dotted #888; color: black}
  #iform button {display: none}

  code, pre, #src { font-family: "Open Sans", sans; font-size: 12pt; }
  pre, #src { background: #eee; padding: .5em; overflow: auto; margin: 0; }

  pre.ins-top { border-top: 10px solid white; }
  pre.ins-bot { border-bottom: 10px solid white; }
  pre.ins-top, pre.ins-bot { cursor: pointer }
  pre:hover { z-index: 100 }

  p[contentEditable=true] { outline: none; min-height: 19px; }

  pre, .comment { position: relative; }
  .comment p { margin: 0; }
  .comment { padding: .5em; }
  .delete-button { display: none; position: absolute; right: .25em; top: calc(.5em); height: 1em; cursor: pointer; }
  .ins-top .delete-button { top: calc(.5em - 5px); }
  :hover > .delete-button { display: block; }
  .delete-button:hover { color: #800; }
</style>
<body>

  <pre id=prelude>
    :Id = lft :code
    :Then = lft rgt :code
    :Test = lft rgt rgt :code
    :Void = lft rgt rgt rgt :code
    :Pair = lft rgt rgt rgt rgt :code
    :Fst = lft rgt rgt rgt rgt rgt :code
    :Snd = lft rgt rgt rgt rgt rgt rgt :code
    :Cond = lft rgt rgt rgt rgt rgt rgt rgt :code
    :Lft = lft rgt rgt rgt rgt rgt rgt rgt rgt :code
    :Rgt = lft rgt rgt rgt rgt rgt rgt rgt rgt rgt :code
    :Builtin = lft rgt rgt rgt rgt rgt rgt rgt rgt rgt rgt :code

    Print = {":id",[fst,snd,":then"],":test",":void",[fst,snd,":pair"],":fst",":snd",[fst,snd,":cond"],":lft",":rgt",[,":builtin"]}
  </pre>

  <p>Fine is a programming language—a programming language for manipulating <i>structured data</i>. Every piece of data in Fine is a primitive, or it is structured. Structured data can be “left”, “right”, or “both”, which in other programming languages would be called binary sums and products.</p>

  <p>Here are what the possible values look like, where <code>X</code> is a primitive:</p>

  <pre>X</pre>
  <pre>[X,Y]</pre>
  <pre>X lft</pre>
  <pre>X rgt</pre>

  <p>Those brackets are called “pair”. Note that in Fine we don't really write down data, we write down computations. On the left of the <code>⇒</code> you see computations and on the right you see what those computations produce when run on a primitive.</p>

  <p>There are some more primitives that manipulate values:</p>

  <pre>[A,B] fst</pre>
  <pre>[A,B] snd</pre>
  <pre>lft {A,B}</pre>
  <pre>rgt {A,B}</pre>

  <p>These braces are called “cond”, and they're used for doing different things depending on whether a value is left or right.</p>

  <p><code>test</code> is another handy primitive for combining values:</p>

  <pre>[A lft,B] test</pre>
  <pre>[A rgt,B] test</pre>

  <p>To help you write big programs, you can define commands. Use capital letters on the left hand side of an equality, and you can use the lowercase version later on.</p>

  <pre>X = lft rgt</pre>
  <pre>X x</pre>

  <p>Numbers are a built-in primitive (as are strings):</p>

  <pre>5</pre>
  <pre>[5,5] +</pre>
  <pre>5 [,] +</pre>
  <pre>Double = [,] +</pre>
  <pre>5 double</pre>

  <p>More interesting than working with numbers is working with code, another built-in. Unlike numbers and strings, though, code is structured. You can create the <code>fst</code> instruction using the command <code>:fst</code>, and analogous for the other instructions:</p>

  <pre>:fst</pre>
  <pre>[[:id,:id] :pair,0 :builtin] :then</pre>
  <pre>:id {"is left","is right"}</pre>
  <pre>:test {lft,rgt}</pre>

  <p>The last line shows that <code>test</code> is represented by the data <code>rgt rgt lft</code>. Fine prints code differently (in quotes), but that's just to help you read it. It's really structured data all the way down.</p>

  <p>Another way to get code objects is to use <code>:lookup</code>:</p>

  <pre>"double" :lookup</pre>

  <p>When you have some code, you run it by using the parentheses (pronounced “quote”). The code on the right is run and replaced by its result:</p>

  <pre>5 (,"double" :lookup)</pre>

  <p>A useful primitive is <code>quote</code>, which turns code into code that evaluates to that code. Woah!</p>

  <pre>5 quote</pre>
  <pre>5 lft quote</pre>
  <pre>5 lft lft quote</pre>

  <p>Note the quotes: we are creating the code <code>5 lft lft</code>, not the object <code>5 lft lft</code>. Code objects are interpreted and printed with quotes.</p>

  <pre>:id quote</pre>
  
  <p>Quotes make quotation even easier. The code on the left is passed to the code on the right:</p>

  <pre>([,] +,quote)</pre>
  <pre>(double,quote)</pre>

  <p>How does this work?</p>

  <pre>5 (3,double)</pre>
  <pre>5 (3,(double,quote))</pre>

  <p>Often you use <code>quote</code> and quotations to help create code:</p>

  <pre>If = [[,:id] :pair,(test {snd lft,snd rgt},quote)] :then</pre>

  <p>This definition is a bit confusing. But try it out:</p>

  <pre>A if</pre>
  <pre>[5,0] (equal,if) {[fst,"=",snd],[fst,"≠",snd]}</pre>

  <p>Another, even more confusing definition is this, which passes code to itself:</p>

  <pre>Self = [[quote,:id] :pair,] :then</pre>

  <form target="" method=get id=iform>
    <input id=src></input>
    <button type=submit>Run</button>
  </form>
  <div id=err style="color:red"></div>
</body>

<script src="fine.js"></script>
